var documenterSearchIndex = {"docs":
[{"location":"man/jlweather/#jlweather-demo","page":"jlweather demo","title":"jlweather demo","text":"","category":"section"},{"location":"man/jlweather/","page":"jlweather demo","title":"jlweather demo","text":"jlweather is a Julia port of miniWeather using Jai.","category":"page"},{"location":"man/jlweather/","page":"jlweather demo","title":"jlweather demo","text":"Please see jlweather for the details of the porting.","category":"page"},{"location":"man/guide/#Getting-Started","page":"Getting-Started","title":"Getting-Started","text":"","category":"section"},{"location":"man/guide/","page":"Getting-Started","title":"Getting-Started","text":"AccelInterfaces.jl(Jai) focuses on reusing Fortran and C/C++ codes, especially for large-scale simulation applications, within Julia. Jai does not limit its support to specific languages or programming frameworks, as long as the code can be compiled as a shared library. Currently, Jai supports the basic capabilities of Fortran, C/C++, Fortran OpenMP, Fortran OpenACC, C++ OpenMP, CUDA, as well as HIP.","category":"page"},{"location":"man/guide/#Installation","page":"Getting-Started","title":"Installation","text":"","category":"section"},{"location":"man/guide/","page":"Getting-Started","title":"Getting-Started","text":"Jai can be installed using the Julia package manager. From the Julia REPL, run","category":"page"},{"location":"man/guide/","page":"Getting-Started","title":"Getting-Started","text":"pkg> add AccelInterfaces","category":"page"},{"location":"man/guide/#Preparing-a-Fortran/C/C-code-to-be-called-from-Julia","page":"Getting-Started","title":"Preparing a Fortran/C/C++ code to be called from Julia","text":"","category":"section"},{"location":"man/guide/","page":"Getting-Started","title":"Getting-Started","text":"First, we need to prepare a Fortran/C/C++(\"embedded\") code that will be called from Julia main. The embedded code is the body part of Fortran/C/C++ function without a function signature and a functon end marker(such as \"end function\" in Fortran and \"}\"in C/C++). Jai will use the embedded code to generate a shared library after adding proper function signature based on input variables in Julia.","category":"page"},{"location":"man/guide/","page":"Getting-Started","title":"Getting-Started","text":"User can specify the function body code using Julia string that contains the code, or a Julia string that points to Jai Kernel File(.knl) in simple text format. The following Julia code calculates a vector sum, whose main algorithm is written in Fortran.","category":"page"},{"location":"man/guide/","page":"Getting-Started","title":"Getting-Started","text":"# main.jl\n\nusing AccelInterfaces\n\nkernel_text = \"\"\"\n[fortran]\n    INTEGER i\n\n    DO i=LBOUND(x, 1), UBOUND(x, 1)\n        z(i) = x(i) + y(i)\n    END DO\n\"\"\"","category":"page"},{"location":"man/guide/","page":"Getting-Started","title":"Getting-Started","text":"The \"kernel_text\" string contains a Fortran DO loop that actually calculates the vector sum. The header at the top of the string specifies that the code contains both of Fortran code.","category":"page"},{"location":"man/guide/#Annotating-Julia-main-code-with-Jai-macros","page":"Getting-Started","title":"Annotating Julia main code with Jai macros","text":"","category":"section"},{"location":"man/guide/","page":"Getting-Started","title":"Getting-Started","text":"Once \"embedded\" code is ready as explained in previous section, we need to use Jai macros to drive the execution of the embedded code.","category":"page"},{"location":"man/guide/","page":"Getting-Started","title":"Getting-Started","text":"    # continued from previous Julia code\n\n    const N = 10\n    x = fill(1, N)\n    y = fill(2, N)\n    z = fill(0, N)\n    answer = fill(3, N)\n\n    @jaccel\n\n    @jkernel kernel_text mykernel framework(fortran=\"gfortran -fPIC -shared\")\n\n    @jlaunch mykernel input(x, y)  output(z)\n\n    @jdecel\n\n    @assert z == answer","category":"page"},{"location":"man/guide/#Creates-a-Jai-accelerator-context","page":"Getting-Started","title":"Creates a Jai accelerator context","text":"","category":"section"},{"location":"man/guide/","page":"Getting-Started","title":"Getting-Started","text":"The @jaccel directive creates a Jai accelerator context.","category":"page"},{"location":"man/guide/#Creates-a-Jai-kernel-context","page":"Getting-Started","title":"Creates a Jai kernel context","text":"","category":"section"},{"location":"man/guide/","page":"Getting-Started","title":"Getting-Started","text":"The @jkernel directive creates a Jai kernel context. The user must specify the string of the kernel, as in this example. Alternatively, the user can provide Jai with a path string to a text file that contains the kernel. To identify the kernel context, we use the literal name mykernel.","category":"page"},{"location":"man/guide/","page":"Getting-Started","title":"Getting-Started","text":"The framework clause specifies the kind of acceleration, which in this example is Fortran. The user can provide Jai with the actual compiler command line to generate a shared library. The command line should include the compiler and all compiler flags, except the -o flag, which specifies the name of the output file and the path to the input source file.","category":"page"},{"location":"man/guide/#Launches-a-kernel","page":"Getting-Started","title":"Launches a kernel","text":"","category":"section"},{"location":"man/guide/","page":"Getting-Started","title":"Getting-Started","text":"The first argument to the @jlaunch directive is the name of the kernel context used in the @jkernel directive. The user then adds the names of variables to the input and output clauses accordingly. However, it is important to note that you should only use simple variable names for inputs and outputs to/from the kernel in the @jlaunch directive. For example, you cannot write something like this:","category":"page"},{"location":"man/guide/","page":"Getting-Started","title":"Getting-Started","text":"@jlaunch mykernel input(x+1, func(y)) output(z::Vector) # Jai Syntax Error","category":"page"},{"location":"man/guide/#Remove-a-Jai-accelerator-context","page":"Getting-Started","title":"Remove a Jai accelerator context","text":"","category":"section"},{"location":"man/guide/","page":"Getting-Started","title":"Getting-Started","text":"Lastly, \"@jdecel\" is used to declare the end of the Jai accelerator context.","category":"page"},{"location":"man/guide/#Running-the-Julia-main-code","page":"Getting-Started","title":"Running the Julia main code","text":"","category":"section"},{"location":"man/guide/","page":"Getting-Started","title":"Getting-Started","text":"Run the Julia main. During the first run, Jai will genrate a shared library and load the shared library and finally make a call to the function in the shared library. This process is done automatically and takes some time at the first run. Howver, once the process is finished with success, the generated shared library is cached and will be loaded immediately unless there is no change.","category":"page"},{"location":"man/guide/","page":"Getting-Started","title":"Getting-Started","text":"> julia main.jl","category":"page"},{"location":"man/guide/#Further-readings","page":"Getting-Started","title":"Further readings","text":"","category":"section"},{"location":"man/guide/","page":"Getting-Started","title":"Getting-Started","text":"Examples : Jai examples including using GPU","category":"page"},{"location":"man/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"man/examples/#Simple-OpenAcc-example","page":"Examples","title":"Simple OpenAcc example","text":"","category":"section"},{"location":"man/examples/#Preparing-an-OpenACC-code","page":"Examples","title":"Preparing an OpenACC code","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"User can specify the function body code using Julia string that contains the code, or a Julia string that points to Jai Kernel File(.knl) in simple text format. The following Julia code calculates a vector sum, whose main algorithm is written in Fortran OpenACC.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"# main.jl\n\nusing AccelInterfaces\n\nkernel_text = \"\"\"\n[fortran_openacc]\n    INTEGER i\n\n    !\\$acc parallel loop \n    DO i=LBOUND(x, 1), UBOUND(x, 1)\n        z(i) = x(i) + y(i)\n    END DO\n    !\\$acc end parallel loop\n\"\"\"","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The \"kernel_text\" string contains a Fortran DO loop that actually calculates the vector sum. OpenACC annotations surround the DO loop, and the header at the top of the string specifies that the code contains both of Fortran OpenACC code.","category":"page"},{"location":"man/examples/#Annotating-Julia-main-code-with-Jai-macros","page":"Examples","title":"Annotating Julia main code with Jai macros","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Once \"embedded\" code is ready as explained in previous section, we need to use Jai macros to drive the execution of the embedded code.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"    # continued from previous Julia code\n\n    const N = 10\n    x = fill(1, N)\n    y = fill(2, N)\n    z = fill(0, N)\n    answer = fill(3, N)\n\n    @jkernel kernel_text mykernel framework(fortran_openacc=\"ftn -h acc,noomp -fPIC -shared\")\n\n    @jenterdata alloc(x, y, z) updateto(x, y)\n\n    @jlaunch mykerne input(x, y)  output(z)\n\n    @jexitdata updatefrom(z) delete(x, y, z)\n\n    @jdecel\n\n    @assert z == answer","category":"page"},{"location":"man/examples/#Creates-a-Jai-accelerator-context","page":"Examples","title":"Creates a Jai accelerator context","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The @jaccel directive creates a Jai accelerator context.","category":"page"},{"location":"man/examples/#Creates-a-Jai-kernel-context","page":"Examples","title":"Creates a Jai kernel context","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The @jkernel directive creates a Jai kernel context. As a first caluse of @jkernel, users should specify the Jai Kernel through a Julia string as in this example. Alternatively, the user can provide Jai with a path string to a text file that contains the kernel. To identify the kernel context, we use the literal name mykernel.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The framework clause specifies the kind of acceleration, which in this example is Fortran OpenACC. The user can provide Jai with the actual compiler command line to generate a shared library. The command line should include the compiler and all compiler flags, except the -o flag, which specifies the name of the output file and the path to the input source file.","category":"page"},{"location":"man/examples/#Allocate-GPU-memory-and-copy-data-from-Julia-Arrays-to-GPU-memory","page":"Examples","title":"Allocate GPU memory and copy data from Julia Arrays to GPU memory","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The @jenterdata directive is used to allocate GPU memory and copy data from CPU to GPU. Once the user adds Julia variable names, Jai uses the data movement API according to the framework used, OpenACC in this case.","category":"page"},{"location":"man/examples/#Launches-a-kernel","page":"Examples","title":"Launches a kernel","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The first argument to the @jlaunch directive is the name of the kernel context used in the @jkernel directive. The user then adds the names of variables to the input and output clauses accordingly. However, it is important to note that you should only use simple variable names for inputs and outputs to/from the kernel in the @jlaunch directive. For example, you cannot write something like this:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"@jlaunch mykernel input(x+1, func(y)) output(z::Vector) # Jai Syntax Error","category":"page"},{"location":"man/examples/#Copy-data-from-GPU-memory-to-Julia-Arrays-and-deallocate-GPU-memory","page":"Examples","title":"Copy data from GPU memory to Julia Arrays and deallocate GPU memory","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The @jexitdata directive is used to deallocate GPU memory and copy data from GPU to CPU. Once the user adds Julia variable names, Jai uses the data movement API according to the framework used, OpenACC in this case.","category":"page"},{"location":"man/examples/#Remove-a-Jai-accelerator-context","page":"Examples","title":"Remove a Jai accelerator context","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Lastly, \"@jdecel\" is used to declare the end of the Jai accelerator context.","category":"page"},{"location":"man/examples/#Running-the-Julia-main-code","page":"Examples","title":"Running the Julia main code","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Run the Julia main. During the first run, Jai will genrate a shared library and load the shared library and finally make a call to the function in the shared library. This process is done automatically and takes some time at the first run. Howver, once the process is finished with success, the generated shared library is cached and will be loaded immediately unless there is no change.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"> julia main.jl","category":"page"},{"location":"man/examples/#Further-readings","page":"Examples","title":"Further readings","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"jlweather : Jai implementations of miniWeather","category":"page"},{"location":"#Julia-AccelInterfaces.jl-(**Jai**)","page":"Julia AccelInterfaces.jl (Jai)","title":"Julia AccelInterfaces.jl (Jai)","text":"","category":"section"},{"location":"","page":"Julia AccelInterfaces.jl (Jai)","title":"Julia AccelInterfaces.jl (Jai)","text":"Accelerator programming interfaces for Julia programmers","category":"page"},{"location":"","page":"Julia AccelInterfaces.jl (Jai)","title":"Julia AccelInterfaces.jl (Jai)","text":"A package for reusing Fortran/C/C++ codes of large-scale simulations in Julia.","category":"page"},{"location":"#Package-Features","page":"Julia AccelInterfaces.jl (Jai)","title":"Package Features","text":"","category":"section"},{"location":"","page":"Julia AccelInterfaces.jl (Jai)","title":"Julia AccelInterfaces.jl (Jai)","text":"Provides Julia users with an OpenMP-like macro interface to run CPU and GPU code.\nAutomatically generates a shared library of pre-existing Fortran/C/C++ code so that it can be called from Julia.\nProvides a simple interface to exchange data between Julia Arrays and GPU memory.\nAllows different CPU and GPU programming frameworks to coexist within an application.\nBoosts the performance of original code through just-in-time compilation.","category":"page"},{"location":"","page":"Julia AccelInterfaces.jl (Jai)","title":"Julia AccelInterfaces.jl (Jai)","text":"warning: Warning\nThis package is in the early stages of development. Please use it at your own risk.","category":"page"},{"location":"","page":"Julia AccelInterfaces.jl (Jai)","title":"Julia AccelInterfaces.jl (Jai)","text":"The Getting-Started provides a tutorial explaining how to get started using AccelInterfaces.","category":"page"},{"location":"","page":"Julia AccelInterfaces.jl (Jai)","title":"Julia AccelInterfaces.jl (Jai)","text":"The Examples shows a Jai example for OpenACC.","category":"page"},{"location":"","page":"Julia AccelInterfaces.jl (Jai)","title":"Julia AccelInterfaces.jl (Jai)","text":"jlweather demo is a Julia port of miniWeather using Jai.","category":"page"},{"location":"","page":"Julia AccelInterfaces.jl (Jai)","title":"Julia AccelInterfaces.jl (Jai)","text":"See Jai API for the explations of Jai macros.","category":"page"},{"location":"man/api/#Jai-API","page":"Jai API","title":"Jai API","text":"","category":"section"},{"location":"man/api/","page":"Jai API","title":"Jai API","text":"Using Jai API, Julia user can easily run CPU or GPU codes written in Fortran/C/C++.","category":"page"},{"location":"man/api/#list-of-Jai-API","page":"Jai API","title":"list of Jai API","text":"","category":"section"},{"location":"man/api/","page":"Jai API","title":"Jai API","text":"Jai API is consist of serveral Julia macros.","category":"page"},{"location":"man/api/","page":"Jai API","title":"Jai API","text":"Modules = [AccelInterfaces]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"man/api/#Detailed-API","page":"Jai API","title":"Detailed API","text":"","category":"section"},{"location":"man/api/","page":"Jai API","title":"Jai API","text":"Modules = [AccelInterfaces]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"man/api/#AccelInterfaces.@jaccel-Tuple","page":"Jai API","title":"AccelInterfaces.@jaccel","text":"@jaccel [name][, clauses...]\n\nCreate accelerator context.\n\nIf name is not specified, this context can be accessed only as the currently active context.\n\nArguments\n\nname: a unique name for this accelerator context\nframework: a list the framework names and compiler-command for the frameworks\ndevice: device number \nconstant: list of constant variables to be available in all kernels\nset: set several options for the accelerator context including \"workdir\" for working directory, \"debug\" for enabling debugging feature.\n\nSee also @jdecel, @jkernel\n\nExamples\n\njulia> @jaccel myacc framework(fortran=\"gfortran -fPIC -shared -g\")\nAccelInfo\n\n\n\n\n\n","category":"macro"},{"location":"man/api/#AccelInterfaces.@jdecel-Tuple","page":"Jai API","title":"AccelInterfaces.@jdecel","text":"@jdecel [name]\n\nDelete an accelerator context.\n\nIf name is not specified, this context can be accessed only as the currently active context.\n\nArguments\n\nname: a unique name for this accelerator context\n\nSee also @jaccel, @jkernel\n\nExamples\n\njulia> @jdecel myacc\n\n\n\n\n\n","category":"macro"},{"location":"man/api/#AccelInterfaces.@jenterdata-Tuple","page":"Jai API","title":"AccelInterfaces.@jenterdata","text":"@jenterdata [name][, clauses...]\n\nAllocate device memory or copy data to device memory.\n\nIf name is not specified, the currently active accel context will be used.\n\nArguments\n\nname: a unique name for the accelerator context\nalloc: a list of variable names to be allocated in an accelerator memory\nupdateto: a list of variable names whose content will be copied to an accelerator \n\nSee also @jaccel, @jkernel\n\nExamples\n\njulia> @jenterdata myacc alloc(X, Y, Z) updateto(X, Y, Z)\n\n\n\n\n\n","category":"macro"},{"location":"man/api/#AccelInterfaces.@jexitdata-Tuple","page":"Jai API","title":"AccelInterfaces.@jexitdata","text":"@jexitdata [name][, clauses...]\n\nDealloc device memory or copy data from device memory.\n\nIf name is not specified, the currently active accel context will be used.\n\nArguments\n\nname: a unique name for the accelerator context\ndelete: a list of variable names to be deallocated in an accelerator memory\nupdatefrom: a list of variable names whose GPU content will be copied to host\n\nSee also @jaccel, @jkernel\n\nExamples\n\njulia> @jexitdata myacc delete(X, Y, Z) updatefrom(X, Y, Z)\n\n\n\n\n\n","category":"macro"},{"location":"man/api/#AccelInterfaces.@jkernel-Tuple{Any, Vararg{Any}}","page":"Jai API","title":"AccelInterfaces.@jkernel","text":"@jkernel kerneldef, [kernelname, [accelname, ]][clauses...]\n\nCreate kernel context.\n\nIf kernelname or accelname is not specified, the currently active accel or kernel context will be used.\n\nArguments\n\nkerneldef: Jai kernel definition\nkernelname: Kernel context name\naccelname: Accelerator context name\nframework: a list the framework names and compiler-command for the frameworks\n\nSee also @jaccel, @jenterdata\n\nExamples\n\njulia> @jkernel filepath mykernel myaccel framework(fortran=\"gfortran -fPIC -shared -g\")\n\n\n\n\n\n","category":"macro"},{"location":"man/api/#AccelInterfaces.@jlaunch-Tuple","page":"Jai API","title":"AccelInterfaces.@jlaunch","text":"@jlaunch [kernelname, [accelname, ]][clauses...]\n\nLaunch a kernel on an accelerator.\n\nIf kernelname or accelname is not specified, the currently active accel or kernel context will be used.\n\nArguments\n\nkernelname: Kernel context name\naccelname: Accel context name\ninput: a list of input variables to the kernel\noutput: a list of output variables to the kernel\nhip: a list of hip launch configurations\ncuda: a list of cuda launch configurations\n\nSee also @jaccel, @jkernel\n\nExamples\n\njulia> @jlaunch mykernel myaccel input(X, Y) output(Z) hip(threads=((1,1,1), (256,1,1)),enable_if=true)\n\n\n\n\n\n","category":"macro"},{"location":"man/api/#AccelInterfaces.@jwait-Tuple","page":"Jai API","title":"AccelInterfaces.@jwait","text":"@jwait [accelname]\n\nWait to finish device operation\n\nIf accelname is not specified, the currently active accel context will be used.\n\nArguments\n\naccelname: Accel context name\n\nSee also @jaccel, @jkernel\n\nExamples\n\njulia> @jwait myaccel\n\n\n\n\n\n","category":"macro"}]
}
